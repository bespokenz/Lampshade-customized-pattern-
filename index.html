<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bespoke Shade Maker — Lampshade Pattern PWA</title>
  <meta name="theme-color" content="#2b6cb0">
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <style>
    :root{--bg:#f7fbff;--card:#fff;--accent:#2b6cb0;--muted:#637381}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans',sans-serif;background:var(--bg);color:#0b1220;font-size:20px;touch-action:manipulation}
    .wrap{max-width:800px;margin:8px auto;padding:8px}
    header{display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:22px}
    .card{background:var(--card);border-radius:12px;padding:10px;box-shadow:0 3px 10px rgba(11,18,32,.10);margin-bottom:10px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
    label{display:block;font-size:15px;color:var(--muted);margin-bottom:6px}
    input[type=number],select{width:100%;padding:14px 8px;border-radius:8px;border:1px solid #e6eef6;font-size:18px}
    .row{display:flex;gap:8px}
    .small{width:120px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:14px;flex-wrap:wrap;}
    button{background:var(--accent);border:none;color:white;padding:18px 0;border-radius:8px;font-weight:600;cursor:pointer;font-size:18px;width:100%;margin-top:8px}
    .footer,.info{font-size:15px;color:var(--muted);margin-top:12px}
    @media (max-width:700px){body{font-size:22px;}.wrap{max-width:none;margin:0;padding:0}.grid{grid-template-columns:1fr}.card{padding:8px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="card" style="display:inline-flex;padding:10px 14px;align-items:center;gap:12px">
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden>
          <path d="M12 2l2.5 5 5.5 1-4 4 1 5.5L12 16l-5 3.5L8 12 4 8l5.5-1L12 2z" fill="#2b6cb0" />
        </svg>
        <div>
          <h1>Bespoke Shade Maker</h1>
          <div style="font-size:13px;color:var(--muted)">Create printable lampshade templates — PWA-ready</div>
        </div>
      </div>
      <div style="flex:1"></div>
    </header>
    <div class="grid">
      <div class="card">
        <h2 style="margin:0 0 8px 0">Inputs</h2>
        <div style="display:grid;gap:10px">
          <div>
            <label>Units</label>
            <div class="row">
              <select id="unit">
                <option value="mm">Millimetres (mm)</option>
                <option value="in">Inches (in)</option>
              </select>
              <div style="display:flex;align-items:center;margin-left:6px;color:var(--muted);font-size:15px">Toggle units — inputs update</div>
            </div>
          </div>
          <div class="row">
            <div style="flex:1">
              <label>Top diameter</label>
              <input id="topD" type="number" step="0.1" min="1" value="150" />
            </div>
            <div style="flex:1">
              <label>Bottom diameter</label>
              <input id="botD" type="number" step="0.1" min="1" value="300" />
            </div>
          </div>
          <div>
            <label>Height (vertical)</label>
            <input id="height" type="number" step="0.1" min="1" value="220" />
          </div>
          <div class="row">
            <div style="flex:1">
              <label>Seam allowance (along straight edge)</label>
              <input id="seam" type="number" step="0.1" min="0" value="10" />
            </div>
            <div style="flex:1">
              <label>Bend allowance (top/bottom fold)</label>
              <input id="fold" type="number" step="0.1" min="0" value="8" />
            </div>
          </div>
          <div>
            <label>Scale to fit page width when printing</label>
            <select id="paperScale">
              <option value="fit">Fit to page width (A4/Letter)</option>
              <option value="1">1:1 (actual size)</option>
              <option value="0.5">50%</option>
            </select>
          </div>
          <div class="controls">
            <!-- Will be replaced by script with Open / Print / Download buttons -->
          </div>
          <div class="info">
            This generator calculates the unwrapped lateral surface of a lampshade (truncated cone). The template will be exported as a printable, multipage PDF, ready for assembly. Mathematical notes are shown on the template.
          </div>
        </div>
      </div>
    </div>
    <footer style="margin-top:14px;text-align:center;color:var(--muted);font-size:13px">Offline-capable PWA — add to home screen to install.</footer>
  </div>
  <script>
    // --- PDF + Geometry Utilities ---
    function toMM(value, unit){ return unit === 'mm' ? Number(value) : Number(value) * 25.4 }
    function fromMM(value, unit){ return unit === 'mm' ? value : value / 25.4 }
    function computeAnnularSector(r1, r2, h){
      if (r2 === r1) r2 = r1 + 0.00001;
      const s = Math.sqrt((r2 - r1) * (r2 - r1) + h * h);
      const L2 = s * r2 / (r2 - r1);
      const L1 = s * r1 / (r2 - r1);
      const theta = 2 * Math.PI * (r2 - r1) / s;
      return {s, L1, L2, theta};
    }
    function polarToCartesian(r, angle, cx, cy){
      return {x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle)};
    }

    // UI: replace single button with Open + Print + Download
    const controls = document.querySelector('.controls');
    controls.innerHTML = `
      <button id="openPdfBtn" style="width:32%;">Open PDF</button>
      <button id="printPdfBtn" style="width:32%;">Print PDF</button>
      <button id="downloadPdfBtn" style="width:32%;">Download PDF</button>
    `;

    async function generatePdfBlob(options = {}) {
      const unit = document.getElementById('unit').value;
      const topD = Number(document.getElementById('topD').value);
      const botD = Number(document.getElementById('botD').value);
      const height = Number(document.getElementById('height').value);
      const seam = Number(document.getElementById('seam').value);
      const fold = Number(document.getElementById('fold').value);
      const paperScale = document.getElementById('paperScale').value;

      // Wait for pdf-lib to be present on window (some environments may load it slightly after this script)
      async function waitForPDFLib(timeoutMs = 3000) {
        const start = Date.now();
        while (true) {
          if (window.PDFLib) return window.PDFLib;
          if (window.pdfLib) return window.pdfLib;
          // some builds attach as global default export under 'PDFLib'
          if (Date.now() - start > timeoutMs) break;
          await new Promise(r => setTimeout(r, 100));
        }
        throw new Error('pdf-lib not available on window after waiting. Make sure the <script> tag for pdf-lib is present and reachable.');
      }

      let PDFLib;
      try {
        PDFLib = await waitForPDFLib();
      } catch (err) {
        console.error('Failed to find pdf-lib:', err);
        throw err;
      }

      const { PDFDocument } = PDFLib;
      const pdfDoc = await PDFDocument.create();

      // PDF: A4 (595x842pt)
      const pageWidth = 595, pageHeight = 842, marginPt = 28;
      // convert mm <-> points
      const mmToPt = 72 / 25.4;

      // Geometry calculations in mm
      const topR = toMM(topD / 2, unit), botR = toMM(botD / 2, unit), h = toMM(height, unit);
      const seamMM = toMM(seam, unit), foldMM = toMM(fold, unit);
      const geom = computeAnnularSector(topR, botR, h);
      // sector radii in mm
      const rInnerMM = geom.L1 + foldMM;
      const rOuterMM = geom.L2 + foldMM + seamMM;
      const angleSpan = geom.theta; // radians

      // convert to points
      const rInnerPt = rInnerMM * mmToPt;
      const rOuterPt = rOuterMM * mmToPt;

      // prepare full drawing size (in points)
      const headerHeight = 40; // space for title etc (points)
      const contentWidthPt = Math.ceil(2 * rOuterPt);
      const contentHeightPt = Math.ceil(2 * rOuterPt);
      const fullWidthPt = contentWidthPt + marginPt * 2;
      const fullHeightPt = headerHeight + contentHeightPt + marginPt * 2 + 20; // extra bottom space

      // compute scale:
      let userScale = 1;
      if (paperScale === '0.5') userScale = 0.5;
      else if (paperScale === '1') userScale = 1;
      else if (paperScale === 'fit') {
        const printableWidth = pageWidth - marginPt * 2;
        userScale = Math.min(1, printableWidth / fullWidthPt);
      }

      // device pixel ratio to create crisp canvases and to correctly slice in pixels
      const dpr = window.devicePixelRatio || 1;

      // final canvas pixel sizes (we will draw in pt units but scale by userScale and dpr)
      const fullCanvasWpx = Math.max(1, Math.ceil(fullWidthPt * userScale * dpr));
      const fullCanvasHpx = Math.max(1, Math.ceil(fullHeightPt * userScale * dpr));

      // create a big offscreen canvas for the whole template
      const fullCanvas = document.createElement('canvas');
      fullCanvas.width = fullCanvasWpx;
      fullCanvas.height = fullCanvasHpx;
      // keep style sizes consistent (not strictly necessary for offscreen but helps debugging)
      fullCanvas.style.width = (fullWidthPt * userScale) + 'px';
      fullCanvas.style.height = (fullHeightPt * userScale) + 'px';

      const fctx = fullCanvas.getContext('2d');

      // scale so 1 point unit maps to (userScale * dpr) canvas pixels
      fctx.save();
      fctx.setTransform(userScale * dpr, 0, 0, userScale * dpr, 0, 0);

      // white background (in points)
      fctx.fillStyle = '#ffffff';
      fctx.fillRect(0, 0, fullWidthPt, fullHeightPt);

      // title (font size in points)
      fctx.fillStyle = '#1f2d55';
      fctx.font = '16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
      fctx.fillText('Lampshade Template', marginPt, 28);

      // center for the sector (in points)
      const cx = marginPt + rOuterPt;
      const cy = marginPt + headerHeight + rOuterPt;

      // draw annular sector (coordinates in points)
      const steps = Math.max(120, Math.floor((angleSpan / (Math.PI * 2)) * 360)); // resolution based on angle
      fctx.beginPath();
      for (let i = 0; i <= steps; i++) {
        const t = -angleSpan / 2 + (angleSpan) * (i / steps);
        const p = polarToCartesian(rOuterPt, t, cx, cy);
        if (i === 0) fctx.moveTo(p.x, p.y); else fctx.lineTo(p.x, p.y);
      }
      for (let i = steps; i >= 0; i--) {
        const t = -angleSpan / 2 + (angleSpan) * (i / steps);
        const p = polarToCartesian(rInnerPt, t, cx, cy);
        fctx.lineTo(p.x, p.y);
      }
      fctx.closePath();
      fctx.fillStyle = '#ffffff';
      fctx.fill();
      fctx.lineWidth = 2;
      fctx.strokeStyle = '#2b6cb0';
      fctx.stroke();

      // dashed cut/align lines at the ends of the sector
      const startAngle = -angleSpan / 2;
      const endAngle = angleSpan / 2;
      const startPtOut = polarToCartesian(rOuterPt, startAngle, cx, cy);
      const startPtIn = polarToCartesian(rInnerPt, startAngle, cx, cy);
      const endPtOut = polarToCartesian(rOuterPt, endAngle, cx, cy);
      const endPtIn = polarToCartesian(rInnerPt, endAngle, cx, cy);

      fctx.setLineDash([6, 4]);
      fctx.strokeStyle = 'rgba(200,40,40,0.95)';
      fctx.lineWidth = 1.5;
      fctx.beginPath();
      fctx.moveTo(startPtOut.x, startPtOut.y);
      fctx.lineTo(startPtIn.x, startPtIn.y);
      fctx.stroke();

      fctx.beginPath();
      fctx.moveTo(endPtOut.x, endPtOut.y);
      fctx.lineTo(endPtIn.x, endPtIn.y);
      fctx.stroke();
      fctx.setLineDash([]);

      // page join labels (position in points)
      fctx.fillStyle = 'rgba(60,10,40,0.8)';
      fctx.font = '10px system-ui, sans-serif';
      fctx.fillText(`Outer radius: ${fromMM(rOuterMM, unit).toFixed(2)} ${unit}`, marginPt, fullHeightPt - marginPt - 8);
      fctx.fillText(`Inner radius: ${fromMM(rInnerMM, unit).toFixed(2)} ${unit}`, marginPt, fullHeightPt - marginPt - 22);
      fctx.fillText(`Sector angle: ${(geom.theta * 180 / Math.PI).toFixed(2)}°`, marginPt, fullHeightPt - marginPt - 36);

      fctx.restore();

      // Now slice the large canvas into A4 pages (with margins).
      const marginPx = marginPt * userScale * dpr;
      const tileWpx = Math.floor((pageWidth - marginPt * 2) * userScale * dpr);
      const tileHpx = Math.floor((pageHeight - marginPt * 2) * userScale * dpr);

      // Ensure tile px at least 1
      const effectiveTileW = Math.max(1, tileWpx);
      const effectiveTileH = Math.max(1, tileHpx);

      let pageNum = 1;
      for (let y = 0; y < fullCanvas.height; y += effectiveTileH) {
        for (let x = 0; x < fullCanvas.width; x += effectiveTileW) {
          // create page canvas (high-DPI)
          const pageCanvas = document.createElement('canvas');
          pageCanvas.width = Math.ceil(pageWidth * dpr);
          pageCanvas.height = Math.ceil(pageHeight * dpr);
          pageCanvas.style.width = pageWidth + 'px';
          pageCanvas.style.height = pageHeight + 'px';
          const pctx = pageCanvas.getContext('2d');

          // white background (in px)
          pctx.fillStyle = '#ffffff';
          pctx.fillRect(0, 0, pageCanvas.width, pageCanvas.height);

          // compute source width/height in px
          const srcW = Math.min(effectiveTileW, fullCanvas.width - x);
          const srcH = Math.min(effectiveTileH, fullCanvas.height - y);

          // draw cropped portion of the full canvas onto the page canvas at margin position (all in px)
          pctx.drawImage(
            fullCanvas,
            x, y, // source x,y in px
            srcW, // source w
            srcH, // source h
            marginPx, marginPx, // dest x,y in px
            srcW, // dest w (px)
            srcH // dest h (px)
          );

          // small page label for alignment (use non-scaled px coords)
          pctx.fillStyle = 'rgba(0,0,0,0.65)';
          pctx.font = Math.round(10 * dpr) + 'px system-ui, sans-serif';
          pctx.fillText(`Pg ${pageNum}`, marginPx + 4, 18 * dpr);

          // embed the canvas as PNG image into pdf-lib
          try {
            const dataUrl = pageCanvas.toDataURL('image/png');
            const arrayBuffer = await (await fetch(dataUrl)).arrayBuffer();
            const pngBytes = new Uint8Array(arrayBuffer); // ensure correct type
            const embeddedImage = await pdfDoc.embedPng(pngBytes);
            const page = pdfDoc.addPage([pageWidth, pageHeight]);
            page.drawImage(embeddedImage, {
              x: 0,
              y: 0,
              width: pageWidth,
              height: pageHeight
            });
          } catch (imgErr) {
            console.error('Failed to embed page canvas into PDF on page', pageNum, imgErr);
            throw imgErr;
          }

          pageNum++;
        }
      }

      try {
        const pdfBytes = await pdfDoc.save();
        return new Blob([pdfBytes], { type: 'application/pdf' });
      } catch (saveErr) {
        console.error('Failed to save PDF document', saveErr);
        throw saveErr;
      }
    }

    async function openPdf() {
      try {
        const blob = await generatePdfBlob();
        const url = URL.createObjectURL(blob);
        const ok = window.open(url, '_blank');
        if (!ok) {
          const a = document.createElement('a');
          a.href = url;
          a.download = 'lampshade-template.pdf';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 60000);
          alert('Popup blocked. The PDF was downloaded instead.');
          return;
        }
        // cleanup after some time
        setTimeout(() => URL.revokeObjectURL(url), 60_000);
      } catch (err) {
        console.error(err);
        alert('Failed to generate PDF: ' + (err && err.message ? err.message : err));
      }
    }

    async function printPdf() {
      try {
        const blob = await generatePdfBlob();
        const url = URL.createObjectURL(blob);
        const w = window.open('', '_blank');
        if (!w) {
          alert('Popup blocked. Please allow popups to use the print workflow.');
          URL.revokeObjectURL(url);
          return;
        }
        // write an iframe that will call print when loaded. Using onload to call print; if that fails, provide download fallback.
        const html = `<!doctype html><html><head><meta name="viewport" content="width=device-width,initial-scale=1" /><title>Print PDF</title></head><body style="margin:0">
          <iframe id="pdfFrame" src="${url}" style="border:none;width:100%;height:100vh;"></iframe>
          <script>
            const f = document.getElementById('pdfFrame');
            function tryPrint(){
              try {
                f.contentWindow.focus();
                f.contentWindow.print();
              } catch(e) {
                try {
                  const a = document.createElement('a');
                  a.href = '${url}';
                  a.download = 'lampshade-template.pdf';
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                } catch(e2){
                  console.error(e2);
                }
                console.error(e);
              }
            }
            f.onload = function(){ setTimeout(tryPrint, 350); };
            // safety: if iframe doesn't load in 10s, show basic link
            setTimeout(function(){
              if(!document.getElementById('dl')){
                var p = document.createElement('p');
                p.id='dl';
                p.innerHTML='<a href="${url}" download>Download PDF</a>';
                document.body.appendChild(p);
              }
            }, 10000);
          <\/script>
        </body></html>`;
        w.document.open();
        w.document.write(html);
        w.document.close();

        // revoke URL later to avoid breaking the embed
        setTimeout(() => URL.revokeObjectURL(url), 120_000);
      } catch (err) {
        console.error(err);
        alert('Failed to generate/print PDF: ' + (err && err.message ? err.message : err));
      }
    }

    // New: download directly (reliable on Android/desktop)
    async function downloadPdf() {
      try {
        const blob = await generatePdfBlob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'lampshade-template.pdf';
        document.body.appendChild(a);
        a.click();
        a.remove();
        // revoke shortly after to allow download to start
        setTimeout(() => URL.revokeObjectURL(url), 60000);
      } catch (err) {
        console.error(err);
        alert('Failed to download PDF: ' + (err && err.message ? err.message : err));
      }
    }

    document.getElementById('openPdfBtn').addEventListener('click', openPdf);
    document.getElementById('printPdfBtn').addEventListener('click', printPdf);
    document.getElementById('downloadPdfBtn').addEventListener('click', downloadPdf);

    // PWA service worker remains unchanged
    const swScript = `self.addEventListener('install', event => { self.skipWaiting(); });
      self.addEventListener('activate', event => { event.waitUntil(self.clients.claim()); });
      self.addEventListener('fetch', event => { event.respondWith(fetch(event.request).catch(()=>caches.match(event.request))); });`;
    if ('serviceWorker' in navigator){
      const blob = new Blob([swScript],{type:'application/javascript'});
      const swUrl = URL.createObjectURL(blob);
      navigator.serviceWorker.register(swUrl).then(()=>console.log('SW registered')).catch(()=>console.log('SW registration failed'));
    }
  </script>
</body>
</html>